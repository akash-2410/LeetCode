____________________________________________________________________________________________Question_____________________________________________________________________________________________
You are given a sorted integer array arr containing 1 and prime numbers, where all the integers of arr are unique. You are also given an integer k.

For every i and j where 0 <= i < j < arr.length, we consider the fraction arr[i] / arr[j].

Return the kth smallest fraction considered. Return your answer as an array of integers of size 2, where answer[0] == arr[i] and answer[1] == arr[j].
____________________________________________________________________________________________Example_____________________________________________________________________________________________
Example 1:
Input: arr = [1,2,3,5], k = 3
Output: [2,5]
Explanation: The fractions to be considered in sorted order are:
1/5, 1/3, 2/5, 1/2, 3/5, and 2/3.
The third fraction is 2/5.

Example 2:
Input: arr = [1,7], k = 1
Output: [1,7]
____________________________________________________________________________________________Intution_____________________________________________________________________________________________
Exploring all fractions: To find the kth smallest prime fraction, we need to explore all possible fractions formed by pairs of elements from the given array.

Using a priority queue: We use a priority queue to store fractions. However, instead of sorting them in ascending order, we maintain a max heap,
sorting them in descending order of their values.

Adding fractions to the priority queue: As we iterate over pairs of elements in the array, we calculate the fraction formed by dividing the smaller element by the larger one.
We add this fraction along with its numerator and denominator to the priority queue.

Keeping track of the kth smallest: We keep the size of the priority queue limited to k. Whenever the size exceeds k, we remove the largest fraction from the priority queue. 
This ensures that at any point, the priority queue contains the k smallest fractions seen so far.

Retrieving the kth smallest fraction: Once we have iterated through all pairs of elements, the top element of the priority queue will be the kth smallest fraction.
We retrieve its numerator and denominator and return them as the result.
____________________________________________________________________________________________Code________________________________________________________________________________________________
class Solution {
    public int[] kthSmallestPrimeFraction(int[] arr, int k) {
        // Creating a max heap priority queue to store fractions in descending order
        PriorityQueue<double[]> pq = new PriorityQueue<>((a, b) -> Double.compare(b[0], a[0]));

        // Generating all possible fractions from the array
        for (int i = 0; i < arr.length; i++) {
            for (int j = i + 1; j < arr.length; j++) {
                // Calculating the fraction (arr[i] / arr[j])
                double div = (double) arr[i] / arr[j];
                // Adding the fraction to the priority queue
                pq.offer(new double[]{div, (double) arr[i], (double) arr[j]});
                // If the priority queue size exceeds k, remove the largest fraction
                if (pq.size() > k)
                    pq.poll();
            }
        }

        // Retrieving the kth smallest fraction from the priority queue
        double[] vec = pq.peek();
        // Storing the numerator and denominator of the kth smallest fraction in an array
        int[] result = new int[2];
        result[0] = (int) vec[1]; // Numerator
        result[1] = (int) vec[2]; // Denominator
        return result;
    }
}

