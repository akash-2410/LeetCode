---------------------------------------------------------------------------------------------------Question-----------------------------------------------------------------------------------------------------------
Given an integer array nums and an integer k, return the number of good subarrays of nums.
A good array is an array where the number of different integers in that array is exactly k.
For example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.
A subarray is a contiguous part of an array.
---------------------------------------------------------------------------------------------------Example-----------------------------------------------------------------------------------------------------------
Example 1:
Input: nums = [1,2,1,2,3], k = 2
Output: 7
Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]

Example 2:
Input: nums = [1,2,1,3,4], k = 3
Output: 3
Explanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4].
---------------------------------------------------------------------------------------------------Intution- and Code Approach 1-----------------------------------------------------------------------------------
The subarraysWithKDistinct function:
Calls the subarryawithAtmostk function to calculate the count of subarrays with at most K distinct elements.
Calls the subarryawithAtmostk function again with k-1 to calculate the count of subarrays with at most K-1 distinct elements.
Subtracts the count of subarrays with at most K-1 distinct elements from the count of subarrays with at most K distinct elements to get the final result.

The subarryawithAtmostk function:
Initializes a HashMap freq to keep track of the frequency of elements within a sliding window.
Uses two pointers left and right to maintain the window of elements.
Iterates through the array, incrementing right to expand the window and updating the frequency map accordingly.
Adjusts the window by incrementing left until the number of distinct elements in the window exceeds K.
Updates the count of valid subarrays (count) based on the size of the current window.
Returns the total count of subarrays with at most K distinct elements.

Code---------------------------------------------------
class Solution {
    public int subarraysWithKDistinct(int[] nums, int k) {
        int subwithmaxk=subarryawithAtmostk(nums,k);
        int subwithmaxkminusone=subarryawithAtmostk(nums,k-1);
        return subwithmaxk-subwithmaxkminusone;
    }

    public int subarryawithAtmostk(int[] nums,int k){
        HashMap<Integer,Integer> freq= new HashMap<>();
        int left=0,right=0,count=0;

        while(right<nums.length){
            freq.put(nums[right],freq.getOrDefault(nums[right],0)+1);

            while(freq.size()>k){
                freq.put(nums[left],freq.get(nums[left])-1);
                if(freq.get(nums[left])==0){
                    freq.remove(nums[left]);
                }
                left++;
            }
            count+=right-left+1;
            right++;
        }
        return count;
    }
}


---------------------------------------------------------------------------------------------------Intution- and Code Approach 2-----------------------------------------------------------------------------------
Initialization:
Initialize an array numFreq to store the frequency of elements in nums.
Initialize variables distinct (to track the number of distinct elements), start, minEnd, and total (to store the total count of subarrays).

Sliding Window Approach:
Use a sliding window approach to iterate through the array.
Start with minEnd and move it forward until you have K distinct elements in the current window.
Once you have K distinct elements, expand the window further (move maxEnd) until you encounter a new element beyond K distinct elements.
At this point, you have a valid subarray with exactly K distinct elements. Update the total count by adding the length of the subarray (i.e., maxEnd - minEnd + 1).
Move the start pointer forward and shrink the window until you have exactly K distinct elements again. Update the total count accordingly.
Repeat this process until minEnd reaches the end of the array.

Return Result:
Once the loop ends, return the total count of subarrays.

Code---------------------------------------------------------
class Solution {
     public int subarraysWithKDistinct(int[] nums, int K) {
        int[] numFreq = new int[nums.length+1];
        int distinct = 0, start = 0, minEnd = 0, total = 0;
        while (distinct == K || minEnd < nums.length) {
            while (distinct < K && minEnd < nums.length) 
			    if (numFreq[nums[minEnd++]]++ == 0) 
                distinct++;
            int maxEnd = minEnd;
            while (maxEnd < nums.length && numFreq[nums[maxEnd]] > 0)
			    maxEnd++;
            while (distinct == K) {
                if (numFreq[nums[start++]]-- == 1)
                distinct--;
                total += (maxEnd - minEnd + 1);
            }
        }
        return total;
    }
 }



